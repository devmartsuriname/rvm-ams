import { supabase } from '@/integrations/supabase/client'
import type { Tables, TablesInsert, TablesUpdate, Enums } from '@/integrations/supabase/types'

export type Dossier = Tables<'rvm_dossier'>
export type DossierInsert = TablesInsert<'rvm_dossier'>
export type DossierUpdate = TablesUpdate<'rvm_dossier'>
export type DossierStatus = Enums<'dossier_status'>
export type ServiceType = Enums<'service_type'>
export type UrgencyLevel = Enums<'urgency_level'>

export type DossierWithItem = Dossier & {
  rvm_item: Tables<'rvm_item'> | null
}

export type DossierFilters = {
  status?: DossierStatus
  service_type?: ServiceType
  urgency?: UrgencyLevel
  search?: string
}

/**
 * Dossier Service - CRUD operations aligned with RLS permissions
 * INSERT: admin_intake
 * UPDATE: secretary_rvm, admin_dossier (when not decided/archived/cancelled)
 * SELECT: All RVM roles
 */
export const dossierService = {
  /**
   * Fetch dossiers with optional filters
   * Access controlled by RLS
   */
  async fetchDossiers(filters?: DossierFilters) {
    let query = supabase
      .from('rvm_dossier')
      .select('*, rvm_item(*)')
      .order('created_at', { ascending: false })

    if (filters?.status) {
      query = query.eq('status', filters.status)
    }
    if (filters?.service_type) {
      query = query.eq('service_type', filters.service_type)
    }
    if (filters?.urgency) {
      query = query.eq('urgency', filters.urgency)
    }
    if (filters?.search) {
      query = query.or(`title.ilike.%${filters.search}%,dossier_number.ilike.%${filters.search}%`)
    }

    const { data, error } = await query
    if (error) throw error
    return data as DossierWithItem[]
  },

  /**
   * Fetch single dossier by ID with related item
   */
  async fetchDossierById(id: string) {
    const { data, error } = await supabase
      .from('rvm_dossier')
      .select('*, rvm_item(*)')
      .eq('id', id)
      .maybeSingle()

    if (error) throw error
    return data as DossierWithItem | null
  },

  /**
   * Create new dossier with linked rvm_item
   * Requires: admin_intake role
   */
  async createDossier(
    dossierData: {
      title: string
      service_type: ServiceType
      sender_ministry: string
      proposal_subtype?: Enums<'proposal_subtype'> | null
      missive_keyword_id?: string | null
      urgency?: UrgencyLevel | null
      confidentiality_level?: Enums<'confidentiality_level'> | null
      summary?: string | null
      created_by?: string | null
    },
    itemData?: {
      description?: string | null
      reference_code?: string | null
      received_date?: string | null
      attachments_expected?: boolean | null
    }
  ) {
    // Insert dossier first (dossier_number is auto-generated by trigger)
    const { data: dossier, error: dossierError } = await supabase
      .from('rvm_dossier')
      .insert({
        title: dossierData.title,
        service_type: dossierData.service_type,
        sender_ministry: dossierData.sender_ministry,
        proposal_subtype: dossierData.proposal_subtype,
        missive_keyword_id: dossierData.missive_keyword_id,
        urgency: dossierData.urgency ?? 'regular',
        confidentiality_level: dossierData.confidentiality_level ?? 'standard_confidential',
        summary: dossierData.summary,
        created_by: dossierData.created_by,
        dossier_number: '', // Will be auto-generated by trigger
      })
      .select()
      .single()

    if (dossierError) throw dossierError

    // Create linked rvm_item
    const { error: itemError } = await supabase
      .from('rvm_item')
      .insert({
        dossier_id: dossier.id,
        item_type: dossierData.service_type,
        description: itemData?.description ?? null,
        reference_code: itemData?.reference_code ?? null,
        received_date: itemData?.received_date ?? null,
        attachments_expected: itemData?.attachments_expected ?? false,
      })

    if (itemError) {
      // Rollback dossier if item creation fails
      console.error('[DossierService] Failed to create item, dossier orphaned:', itemError)
      throw itemError
    }

    return dossier
  },

  /**
   * Update dossier
   * Requires: secretary_rvm or admin_dossier role
   * RLS prevents update if status is decided/archived/cancelled
   */
  async updateDossier(id: string, data: DossierUpdate) {
    const { data: updated, error } = await supabase
      .from('rvm_dossier')
      .update(data)
      .eq('id', id)
      .select()
      .single()

    if (error) throw error
    return updated
  },

  /**
   * Update dossier status with validation
   * Validates state transition at application level
   */
  async updateDossierStatus(id: string, status: DossierStatus) {
    const { data: updated, error } = await supabase
      .from('rvm_dossier')
      .update({ status })
      .eq('id', id)
      .select()
      .single()

    if (error) throw error
    return updated
  },

  /**
   * Fetch dossiers available for agenda scheduling
   * Status must be 'registered' or 'in_preparation'
   */
  async fetchAgendaEligibleDossiers() {
    const { data, error } = await supabase
      .from('rvm_dossier')
      .select('id, dossier_number, title, service_type, urgency, status')
      .in('status', ['registered', 'in_preparation'])
      .order('urgency', { ascending: false })
      .order('created_at', { ascending: true })

    if (error) throw error
    return data
  },
}
